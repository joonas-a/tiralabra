import random


class Kruskals:
    """Creates a maze of given size with the Kruskal's algorithm

    Contains helper methods to initialize the algorithm along with one
    for execution, that is called from the logic component.

    Args:
        layout: the maze layout (list of lists) generated by the logic component
        maze: the maze frame, needed to draw paths one cell at a time
        visualize: a boolean value, whether to visualize maze creation or not
        sleep_timer: how long to wait for between each move during visualization
    """

    def __init__(self, layout, maze, visualize, sleep_timer):
        self.grid = layout
        self.maze = maze
        self.visualize = visualize
        self.sleep = sleep_timer
        self.height = len(self.grid)
        self.width = len(self.grid[0])
        self.sets = DisjointSet()
        self.walls = []
        self.populate_walls()

    def populate_walls(self):
        # Create the list of all walls in any given layout, ignoring
        # those that are aligned diagonally
        # The walls are also nodes in the graph for visualization purposes
        for row_count, row in enumerate(self.grid):
            for col_count, cell in enumerate(row):
                if cell == 1 and not (row_count % 2 == 1 and col_count % 2 == 1):
                    self.add_wall(col_count, row_count)
        random.shuffle(self.walls)

    def add_wall(self, col, row):
        # Determines whether to compare cells to the left and right,
        # or up and down of the wall based on the wall's location
        if col == 0 or col == (self.width - 1) or col % 2 == 0:
            self.walls.append((col, row, "vertical"))
        elif row == 0 or row == (self.height - 1) or row % 2 == 0:
            self.walls.append((col, row, "horizontal"))

    def run(self):
        while self.walls:
            col, row, direction = self.walls.pop()

            if direction == "horizontal":
                col_a = col - 1
                col_b = col + 1
                row_a, row_b = row, row
            elif direction == "vertical":
                row_a = row - 1
                row_b = row + 1
                col_a, col_b = col, col

            set1 = self.sets.find((row_a, col_a))
            set2 = self.sets.find((row_b, col_b))
            if set1 != set2:
                self.sets.union(set1, set2)
                self.grid[row][col] = 0
                self.grid[row_a][col_a] = 0
                self.grid[row_b][col_b] = 0
                if self.visualize:
                    self.maze.maze.after(
                        self.sleep, self.maze.draw_passage(row, col))
                    self.maze.draw_passage(row_a, col_a)
                    self.maze.draw_passage(row_b, col_b)
                    self.maze.maze.update()

        return self.grid


class DisjointSet:
    """Data structure for efficient execution of the Kruskal's algorithm

    Creates a minimum spanning tree with path compression. Finds if two sets 
    have a common element (parent) and can union two sets together.
    """

    def __init__(self):
        self.parents = {}
        self.ranks = {}

    def find(self, value):
        if value not in self.parents:
            self.parents[value] = value
            self.ranks[value] = 0
            return value
        if self.parents[value] != value:
            self.parents[value] = self.find(self.parents[value])
        return self.parents[value]

    def union(self, set1, set2):
        rootx = self.find(set1)
        rooty = self.find(set2)
        if rootx != rooty:
            if self.ranks[rootx] < self.ranks[rooty]:
                self.parents[rootx] = rooty
            else:
                self.parents[rooty] = rootx
                if self.ranks[rootx] == self.ranks[rooty]:
                    self.ranks[rootx] += 1
